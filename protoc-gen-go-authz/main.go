// protoc-gen-go-authz - Protocol Buffers plugin for generating authorization maps from proto authz options
//
// This plugin extracts authz options from proto service methods and generates
// Go code with authorization rules mapped from HTTP paths to required permissions.
//
// Usage in buf.gen.yaml:
//
//	plugins:
//	  - local: [go, run, ./protoc-gen-go-authz]
//	    out: /gen
//	    opt:
//	      - paths=source_relative
//
// The plugin reads proto files with authz options like:
//
//	option (proto.v1.authz) = { permissions: ["permission1", "permission2"] };
//
// And generates Go code with authorization maps that can be used by middleware.
package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

// authzRule represents a single authorization rule.
type authzRule struct {
	HTTPPath       string
	HTTPMethod     string
	Permissions    []string
	NoAuthRequired bool
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		parser := newProtoAuthzParser()
		var allAuthzRules []authzRule

		// Process each proto file
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			rules := parser.parseFile(file)
			allAuthzRules = append(allAuthzRules, rules...)
		}

		// Always generate the authz map file, even if empty
		// This ensures the package exists for imports
		generateAuthzMapFile(plugin, allAuthzRules)

		return nil
	})
}

// generateAuthzMapFile generates the Go file containing the authorization map.
func generateAuthzMapFile(plugin *protogen.Plugin, rules []authzRule) {
	// Generate in a separate package to avoid circular imports
	filename := "authzmap/generated_authz_map.go"
	gen := plugin.NewGeneratedFile(filename, "github.com/aymenworks/public-medium-protocgen/gen/authzmap")

	// File header and package
	gen.P("// Code generated by protoc-gen-go-authz. DO NOT EDIT.")
	gen.P()
	gen.P("package authzmap")
	gen.P()
	gen.P("import \"strings\"")
	gen.P()

	// Generate the AuthzRule struct
	gen.P("// AuthzRule represents authorization rules for a method")
	gen.P("type AuthzRule struct {")
	gen.P("	Permissions    []string")
	gen.P("	NoAuthRequired bool")
	gen.P("}")
	gen.P()

	// Generate the authorization map
	gen.P("// generatedAuthzMap contains authorization rules extracted from proto definitions")
	gen.P("// This map is automatically generated during go tool buf generate")
	gen.P("var generatedAuthzMap = map[string]AuthzRule{")

	for _, rule := range rules {
		key := rule.HTTPPath + "|" + strings.ToUpper(rule.HTTPMethod)
		permissionsStr := "[]string{"
		for i, permission := range rule.Permissions {
			if i > 0 {
				permissionsStr += ", "
			}
			permissionsStr += `"` + permission + `"`
		}
		permissionsStr += "}"
		gen.P("	" + `"` + key + `"` + ": {")
		gen.P("		Permissions:    " + permissionsStr + ",")
		gen.P("		NoAuthRequired: " + fmt.Sprintf("%t", rule.NoAuthRequired) + ",")
		gen.P("	},")
	}

	gen.P("}")
	gen.P()

	gen.P("// normalizePathForAuthzWithMap converts a path with actual values to its template form")
	gen.P("// by matching against all known parameterized paths in the provided authz map for the given method")
	gen.P("// e.g., \"/v1/foo/123\" -> \"/v1/foo/{foo_id}\"")
	gen.P("func normalizePathForAuthzWithMap(authzMap map[string]AuthzRule, actualPath, method string) string {")
	gen.P("	actualParts := strings.Split(strings.Trim(actualPath, \"/\"), \"/\")")
	gen.P("	")
	gen.P("	// Try to match against all known parameterized paths in the map for this specific method")
	gen.P("	for templatePath := range authzMap {")
	gen.P("		// Only consider templates with matching HTTP method")
	gen.P("		pathAndMethod := strings.Split(templatePath, \"|\")")
	gen.P("		if len(pathAndMethod) != 2 || pathAndMethod[1] != method {")
	gen.P("			continue")
	gen.P("		}")
	gen.P("		path := pathAndMethod[0]")
	gen.P("		templateParts := strings.Split(strings.Trim(path, \"/\"), \"/\")")
	gen.P("		")
	gen.P("		// Skip if different number of path segments")
	gen.P("		if len(actualParts) != len(templateParts) {")
	gen.P("			continue")
	gen.P("		}")
	gen.P("		")
	gen.P("		// Check if the path matches the template")
	gen.P("		matches := true")
	gen.P("		for i := 0; i < len(actualParts); i++ {")
	gen.P("			templatePart := templateParts[i]")
	gen.P("			actualPart := actualParts[i]")
	gen.P("			")
	gen.P("			// If template part is a parameter (enclosed in {})")
	gen.P("			if strings.HasPrefix(templatePart, \"{\") && strings.HasSuffix(templatePart, \"}\") {")
	gen.P("				// Accept any non-empty value for parameter")
	gen.P("				if actualPart == \"\" {")
	gen.P("					matches = false")
	gen.P("					break")
	gen.P("				}")
	gen.P("				// Parameter matches, continue")
	gen.P("				continue")
	gen.P("			}")
	gen.P("			")
	gen.P("			// If template part is literal, it must match exactly")
	gen.P("			if templatePart != actualPart {")
	gen.P("				matches = false")
	gen.P("				break")
	gen.P("			}")
	gen.P("		}")
	gen.P("		")
	gen.P("		// If we found a matching template, return it")
	gen.P("		if matches {")
	gen.P("			return path")
	gen.P("		}")
	gen.P("	}")
	gen.P("	")
	gen.P("	// No template found, return original path")
	gen.P("	return actualPath")
	gen.P("}")
	gen.P()

	gen.P("// normalizePathForAuthz converts a path with actual values to its template form using the default authz map")
	gen.P("func normalizePathForAuthz(actualPath, method string) string {")
	gen.P("	return normalizePathForAuthzWithMap(generatedAuthzMap, actualPath, method)")
	gen.P("}")
	gen.P()

	gen.P("// IsAuthRequiredWithMap returns whether authentication is required for a given path and method using provided authz map")
	gen.P("func IsAuthRequiredWithMap(authzMap map[string]AuthzRule, path, method string) bool {")
	gen.P("	// Health check endpoints do not require authentication")
	gen.P("	if path == \"/v1/health\" && method == \"GET\" {")
	gen.P("		return false")
	gen.P("	}")
	gen.P("	")
	gen.P("	// First try exact match")
	gen.P("	key := path + \"|\" + method")
	gen.P("	rule, exists := authzMap[key]")
	gen.P("	")
	gen.P("	// If not found, try with normalized path for parameterized routes")
	gen.P("	if !exists {")
	gen.P("		normalizedPath := normalizePathForAuthzWithMap(authzMap, path, method)")
	gen.P("		key = normalizedPath + \"|\" + method")
	gen.P("		rule, exists = authzMap[key]")
	gen.P("	}")
	gen.P("	")
	gen.P("	if !exists {")
	gen.P("		return true // Default to requiring auth for undefined paths")
	gen.P("	}")
	gen.P("	return !rule.NoAuthRequired")
	gen.P("}")
	gen.P()

	gen.P("// IsAuthRequired returns whether authentication is required for a given path and method")
	gen.P("func IsAuthRequired(path, method string) bool {")
	gen.P("	return IsAuthRequiredWithMap(generatedAuthzMap, path, method)")
	gen.P("}")
	gen.P()

	gen.P("// HasPermissionWithMap checks if any of the user permissions is allowed for a given path and method using provided authz map")
	gen.P("func HasPermissionWithMap(authzMap map[string]AuthzRule, path, method string, userPermissions []string) bool {")
	gen.P("	// Health check endpoints do not require authentication")
	gen.P("	if path == \"/v1/health\" && method == \"GET\" {")
	gen.P("		return true")
	gen.P("	}")
	gen.P("	")
	gen.P("	// First try exact match")
	gen.P("	key := path + \"|\" + method")
	gen.P("	rule, exists := authzMap[key]")
	gen.P("	")
	gen.P("	// If not found, try with normalized path for parameterized routes")
	gen.P("	if !exists {")
	gen.P("		normalizedPath := normalizePathForAuthzWithMap(authzMap, path, method)")
	gen.P("		key = normalizedPath + \"|\" + method")
	gen.P("		rule, exists = authzMap[key]")
	gen.P("	}")
	gen.P("	")
	gen.P("	if !exists {")
	gen.P("		return false")
	gen.P("	}")
	gen.P()
	gen.P("	// If no auth is required, always allow")
	gen.P("	if rule.NoAuthRequired {")
	gen.P("		return true")
	gen.P("	}")
	gen.P("	")
	gen.P("	// Check if user has any of the required permissions")
	gen.P("	requiredPermissionMap := make(map[string]bool, len(rule.Permissions))")
	gen.P("	for _, permission := range rule.Permissions {")
	gen.P("		requiredPermissionMap[strings.ToLower(permission)] = true")
	gen.P("	}")
	gen.P("	for _, userPermission := range userPermissions {")
	gen.P("		if requiredPermissionMap[strings.ToLower(userPermission)] {")
	gen.P("			return true")
	gen.P("		}")
	gen.P("	}")
	gen.P("	return false")
	gen.P("}")
	gen.P()

	gen.P("// HasPermission checks if any of the user permissions is allowed for a given path and method")
	gen.P("func HasPermission(path, method string, userPermissions []string) bool {")
	gen.P("	return HasPermissionWithMap(generatedAuthzMap, path, method, userPermissions)")
	gen.P("}")
}
