// Code generated by protoc-gen-go-authz. DO NOT EDIT.

package authzmap

import "strings"

// AuthzRule represents authorization rules for a method
type AuthzRule struct {
	Permissions    []string
	NoAuthRequired bool
}

// generatedAuthzMap contains authorization rules extracted from proto definitions
// This map is automatically generated during go tool buf generate
var generatedAuthzMap = map[string]AuthzRule{
	"/v1/test/{foo_id}|POST": {
		Permissions:    []string{},
		NoAuthRequired: true,
	},
	"/v1/test2/{foo_id}|POST": {
		Permissions:    []string{"read:all"},
		NoAuthRequired: false,
	},
}

// normalizePathForAuthzWithMap converts a path with actual values to its template form
// by matching against all known parameterized paths in the provided authz map for the given method
// e.g., "/v1/foo/123" -> "/v1/foo/{foo_id}"
func normalizePathForAuthzWithMap(authzMap map[string]AuthzRule, actualPath, method string) string {
	actualParts := strings.Split(strings.Trim(actualPath, "/"), "/")

	// Try to match against all known parameterized paths in the map for this specific method
	for templatePath := range authzMap {
		// Only consider templates with matching HTTP method
		pathAndMethod := strings.Split(templatePath, "|")
		if len(pathAndMethod) != 2 || pathAndMethod[1] != method {
			continue
		}
		path := pathAndMethod[0]
		templateParts := strings.Split(strings.Trim(path, "/"), "/")

		// Skip if different number of path segments
		if len(actualParts) != len(templateParts) {
			continue
		}

		// Check if the path matches the template
		matches := true
		for i := 0; i < len(actualParts); i++ {
			templatePart := templateParts[i]
			actualPart := actualParts[i]

			// If template part is a parameter (enclosed in {})
			if strings.HasPrefix(templatePart, "{") && strings.HasSuffix(templatePart, "}") {
				// Accept any non-empty value for parameter
				if actualPart == "" {
					matches = false
					break
				}
				// Parameter matches, continue
				continue
			}

			// If template part is literal, it must match exactly
			if templatePart != actualPart {
				matches = false
				break
			}
		}

		// If we found a matching template, return it
		if matches {
			return path
		}
	}

	// No template found, return original path
	return actualPath
}

// normalizePathForAuthz converts a path with actual values to its template form using the default authz map
func normalizePathForAuthz(actualPath, method string) string {
	return normalizePathForAuthzWithMap(generatedAuthzMap, actualPath, method)
}

// IsAuthRequiredWithMap returns whether authentication is required for a given path and method using provided authz map
func IsAuthRequiredWithMap(authzMap map[string]AuthzRule, path, method string) bool {
	// Health check endpoints do not require authentication
	if path == "/v1/health" && method == "GET" {
		return false
	}

	// First try exact match
	key := path + "|" + method
	rule, exists := authzMap[key]

	// If not found, try with normalized path for parameterized routes
	if !exists {
		normalizedPath := normalizePathForAuthzWithMap(authzMap, path, method)
		key = normalizedPath + "|" + method
		rule, exists = authzMap[key]
	}

	if !exists {
		return true // Default to requiring auth for undefined paths
	}
	return !rule.NoAuthRequired
}

// IsAuthRequired returns whether authentication is required for a given path and method
func IsAuthRequired(path, method string) bool {
	return IsAuthRequiredWithMap(generatedAuthzMap, path, method)
}

// HasPermissionWithMap checks if any of the user permissions is allowed for a given path and method using provided authz map
func HasPermissionWithMap(authzMap map[string]AuthzRule, path, method string, userPermissions []string) bool {
	// Health check endpoints do not require authentication
	if path == "/v1/health" && method == "GET" {
		return true
	}

	// First try exact match
	key := path + "|" + method
	rule, exists := authzMap[key]

	// If not found, try with normalized path for parameterized routes
	if !exists {
		normalizedPath := normalizePathForAuthzWithMap(authzMap, path, method)
		key = normalizedPath + "|" + method
		rule, exists = authzMap[key]
	}

	if !exists {
		return false
	}

	// If no auth is required, always allow
	if rule.NoAuthRequired {
		return true
	}

	// Check if user has any of the required permissions
	requiredPermissionMap := make(map[string]bool, len(rule.Permissions))
	for _, permission := range rule.Permissions {
		requiredPermissionMap[strings.ToLower(permission)] = true
	}
	for _, userPermission := range userPermissions {
		if requiredPermissionMap[strings.ToLower(userPermission)] {
			return true
		}
	}
	return false
}

// HasPermission checks if any of the user permissions is allowed for a given path and method
func HasPermission(path, method string, userPermissions []string) bool {
	return HasPermissionWithMap(generatedAuthzMap, path, method, userPermissions)
}
